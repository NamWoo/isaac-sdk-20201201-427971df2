/*
Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.

NVIDIA CORPORATION and its licensors retain all intellectual property
and proprietary rights in and to this software, related documentation
and any modifications thereto. Any use, reproduction, disclosure or
distribution of this software and related documentation without an express
license agreement from NVIDIA CORPORATION is strictly prohibited.
*/
#pragma once

#include "isaac_c_api_error.h"
#include "isaac_c_api_types.h"

#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

//==================================================================================================
// APPLICATION
//==================================================================================================

// Create an ISAAC SDK application.
//
// The application will load a compute graph via JSON files. Application execution will not begin
// until isaac_start_application is called.
// Inputs:
//   asset_path:       The root folder of the ISAAC application. Assets and modules specified in
//                     relative paths are loaded from this. If empty, will use the current path.
//   app_filename:     Filename of the ISAAC app JSON file
//   module_paths:     List of additional paths to load module shared libraries from
//   num_module_paths: The number of module paths in the list
//   json_files:       List of names of additional json files to load for the application
//   num_json_files:   The number of json files in the list
// Outputs:
//    app_handle:      An opaque handle to the application.
isaac_error_t isaac_create_application(const char* asset_path, const char* app_filename,
                                       const char** module_paths, int32_t num_module_paths,
                                       const char** json_files, int32_t num_json_files,
                                       isaac_handle_t* app_handle);

// Destroys the application and all resources generated by the applicaiton.
// If the application has been started it must be stopped before calling this function.
// Not doing so can result in the application not shutting down cleanly and leave dangling
// resources.
// Inputs:
//   app_handle: A handle to the application. Will be placed in an invalid state after the call.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//
isaac_error_t isaac_destroy_application(isaac_handle_t* app_handle);

// Starts the application execution and blocks until start is finished. Currently it is an error to
// call start twice on an application handle. Returns once the application has started.
// Inputs:
//   app_handle: A handle to the application
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//
isaac_error_t isaac_start_application(isaac_handle_t app_handle);

// Stop the application execution and blocks while the app shuts down.
// Currently it is an error to call stop twice on an application handle or
// to call stop without first calling start.
// Inputs:
//   app_handle: A handle to the application
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//
isaac_error_t isaac_stop_application(isaac_handle_t app_handle);

//==================================================================================================
// SEND & RECEIVE MESSAGES
//==================================================================================================

// Create a message to send to IsaacSDK. Message must either be published or destroyed later.
// Inputs:
//   app_handle:   A handle to the application that allocated the buffer.
// Outputs:
//   message_uuid: The UUID of the new message.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//
isaac_error_t isaac_create_message(isaac_handle_t app_handle, isaac_uuid_t* message_uuid);

// Destroy a message.
// Note: Only necessary if the message was not published.
// Inputs:
//   app_handle:   A handle to the application that allocated the buffer.
//   message_uuid: UUID of the message to destroy.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_message_not_found
//
isaac_error_t isaac_destroy_message(isaac_handle_t app_handle, isaac_uuid_t* message_uuid);

// Publish a message to IsaacSDK
// The message needs to be created with isaac_create_message first. It will be published under the
// given UUID and with the current timestamp as pubtime.
// Inputs:
//   app_handle:     A handle to the application that allocated the buffer.
//   node_name:      The target node to receive the message.
//   component_name: The target component within the node.
//   channel_name:   The desired channel to receive the message.
//   message_uuid:   UUID of the message.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_cannot_modify_received_message
//   isaac_error_message_not_found
//
isaac_error_t isaac_publish_message(isaac_handle_t app_handle, const char* node_name,
                                    const char* component_name, const char* channel_name,
                                    const isaac_uuid_t* message_uuid);

// Gets the latest message from the channel that has not been read before.
// This function will create a message handle
// and generate any required buffer handles to be associated with the message.
// This message must be manually released by isaac_release_message later.
// This function is non blocking. It will return as soon as possible with
// either a message or an error code indicating one is not available.
// Inputs:
//   app_handle:     A handle to the application that allocated the buffer.
//   node_name:      The target node that is sending the message.
//   component_name: The target component within the node.
//   channel_name:   The desired channel that is sending the message.
// Outputs:
//   message_uuid:   UUID of the received message.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_no_message_available
//
isaac_error_t isaac_receive_latest_new_message(isaac_handle_t app_handle, const char* node_name,
                                               const char* component_name, const char* channel_name,
                                               isaac_uuid_t* message_uuid);

// Messages which have been recieved must be released to indicate they are no longer of use.
// This will also release any buffer handles which were created during reception of the message.
// Inputs:
//   app_handle:   A handle to the application.
//   message_uuid: UUID of the message to release.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_message_not_found
//
isaac_error_t isaac_release_message(isaac_handle_t app_handle, isaac_uuid_t* message_uuid);

//==================================================================================================
// MISCELLANEOUS
//==================================================================================================

// Gets the clock time from the application.
// Usage Notes:
// 1) use isaac_get_time() to timestamp events. Note that as this is done in the user space,
// accuracy of timestamping is limited.
// 2) use isaac_get_time() to convert ISAAC timestamps to external system timestamps:
// timestamp_in_your_time = isaac_timestamp + (your_steady_clock_get_time() - isaac_get_time())".
// Note, as the function calls are done in user space and not at the same time as isaac_timestamp,
// accuracy is limited.
// Note: Caching this time without periodically refreshing the value can lead
// to clock drift.
// Note: std::chrono::steady_clock is used as a raw time source, but ISAAC may adjust the rate of
// the clock, advance and offset the clock. There are no guarantees on the clock rate or precision.
// Inputs:
//   app_handle: A handle to the application whose clock is to queried.
// Outputs:
//   time: The application clock time in nanoseconds
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_invalid_parameter
//
isaac_error_t isaac_get_time(isaac_handle_t app_handle, int64_t* time);

// Get a pose in the pose tree.
// Note: The application may also change the pose asynchronously.
// Inputs:
//   app_handle: A handle to the application whose pose tree is to be modified.
//   lhs:        The name of the left hand side of the pose descriptor.
//   rhs:        The name of the right hand side of the pose descriptor.
//   time:       The time stamp of the desired pose.
// Outputs:
//   pose: The desired pose at the given time. May be subject to interpolation if
//         time falls between the time stamp of two poses.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_pose
//   isaac_error_invalid_parameter
//
isaac_error_t isaac_get_pose(isaac_handle_t app_handle, const char* lhs, const char* rhs,
                             int64_t time, isaac_pose_t* pose);

// Set a pose in the pose tree.
// Note: The application may also change the pose asynchronously.
// Inputs:
//   app_handle: A handle to the application whose pose tree is to be modified.
//   lhs:        The name of the left hand side of the pose descriptor.
//   rhs:        The name of the right hand side of the pose descriptor.
//   pose:       The new pose to be set on the pose tree.
//   time:       The time stamp to assign to the new pose.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_pose
//
isaac_error_t isaac_set_pose(isaac_handle_t app_handle, const char* lhs, const char* rhs,
                             int64_t time, isaac_pose_t pose);

//==================================================================================================
// SET & GET CONFIGURATION PARAMETERS
//==================================================================================================

// Get an ISAAC parameter as a null-terminated JSON string.
//
// First the configuration value for the configuration paramter `key` in the given component of the
// the given node will be received. If successful the JSON object will be serialized as a string.
// The JSON string will be copied to the provided target buffer if the buffer is big enough to hold
// the full object. In any case the size of the JSON string will written to `json`.
//
// The user maintains full ownership over the provided buffer.
isaac_error_t isaac_get_parameter(isaac_handle_t app_handle, const char* node,
                                  const char* component, const char* key, isaac_json_t* json);

// Set an ISAAC parameter as a JSON string.
//
// This function will set the value for the configuration parameter `key` in the given component of
// the given node. If the parameter does not yet exist it will be created. The given JSON string
// will be parsed into a JSON object and then set in the ISAAC application.
//
// The user maintains full ownership over the provided buffer.
isaac_error_t isaac_set_parameter(isaac_handle_t app_handle, const char* node,
                                  const char* component, const char* key,
                                  const isaac_const_json_t* json);

// Set an ISAAC parameter from a null-terminated JSON string
//
// This is a convenience function for isaac_set_parameter. It is identical to:
//   isaac_const_json_t json;
//   json.data = json_string;
//   json.size = strlen(json_string);
//   isaac_set_parameter(app_handle, node, component, key, &json);
isaac_error_t isaac_set_parameter_from_string(isaac_handle_t app_handle, const char* node,
                                              const char* component, const char* key,
                                              const char* json_string);

//==================================================================================================
// READ & WRITE MESSAGE CONTENTS
//==================================================================================================

// Gets a pointer to the JSON string of a JSON message.
//
// This function will not copy data and only return a pointer to the data. ISAAC will retain full
// ownership over the returned pointer. The string will be null-terminated and the returned size
// will count for the null-terminator.
isaac_error_t isaac_get_message_json(isaac_handle_t app_handle, const isaac_uuid_t* message_uuid,
                                     isaac_const_json_t* json);

// Copies a JSON string from a JSON message to a buffer owned by the caller.
//
// The copied string data will include a null terminator. If the supplied target buffer is null
// or not large enough no data will be copied. In any case the number of bytes which would be
// written will be returned in the `size` argument. The size will count for the null-terminator.
isaac_error_t isaac_read_message_json(isaac_handle_t app_handle, const isaac_uuid_t* message_uuid,
                                      isaac_json_t* json);

// Copies a string from a buffer owned by the caller to the JSON message.
//
// This operation is only valid for messages which have been created by the user. Messages received
// via the C API can not be modified. The input string must be a valid serialized JSON object.
// The input string must be null-terminated and the given size should count for the null-terminator.
isaac_error_t isaac_write_message_json(isaac_handle_t app_handle, const isaac_uuid_t* message_uuid,
                                       const isaac_const_json_t* json);

// Sets the message to be published as JsonMessage or converted to ProtoMessage
//
// This operation is only valid for messages which have been created by the user. Messages received
// via the C API can not be modified.
isaac_error_t isaac_set_message_auto_convert(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                             isaac_message_convert_t flag);

// Get the message acquisition time
// Inputs:
//   app_handle:    A handle to the application which contains the desired message.
//   message_uuid:  UUID of the message.
// Outputs:
//   time:    The acquisition time of the message in nanoseconds
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_invalid_parameter
//
isaac_error_t isaac_get_message_acqtime(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                        int64_t* time);

// Set the message acquisition time. If no time is specified the current ISAAC time at the time
// the message is published will be used.
// Inputs:
//   app_handle:    A handle to the application which contains the desired message.
//   message_uuid:  UUID of the message.
//   time:          The acquisition time of the message in nanoseconds
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_cannot_modify_received_message
//
isaac_error_t isaac_set_message_acqtime(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                        int64_t time);

// Get the message publication time
// Inputs:
//   app_handle:    A handle to the application which contains the desired message.
//   message_uuid:  UUID of the message.
// Outputs:
//   time:    The publication time of the message in nanoseconds
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_invalid_parameter
//
isaac_error_t isaac_get_message_pubtime(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                        int64_t* time);

// Get the message proto id
// Inputs:
//   app_handle:    A handle to the application which contains the desired message.
//   message_uuid:  UUID of the message.
// Outputs:
//   proto_id: The proto id of the message.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_invalid_parameter
//
isaac_error_t isaac_get_message_proto_id(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                         int64_t* proto_id);

// Set the message proto id
// Inputs:
//   app_handle:    A handle to the application which contains the desired message.
//   message_uuid:  UUID of the message.
//   proto_id:      The proto id of the message.
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_cannot_modify_received_message
//
isaac_error_t isaac_set_message_proto_id(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                         uint64_t proto_id);

// Reads the message proto segments data as pointers to the real data. These pointers would be
// invalidated after message is destroyed.
// Inputs:
//   app_handle:    A handle to the application which contains the desired message.
//   message_uuid:  UUID of the message.
//   segments:      array to write pointers to segment data into (could be nullptr)
//   sizes:         array to write segment sizes into (could be nullptr)
//   num_segments:  Length of the buffer
// Outputs:
//   segments:      Array of pointers to data of each segment (invalidated after message destroyed)
//   sizes:         The length of each segment in bytes
//   num_segments:  Number of segments
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_invalid_parameter
//   isaac_error_message_not_found
//
isaac_error_t isaac_read_message_proto_segments(isaac_handle_t app_handle,
                                                isaac_uuid_t* message_uuid, const void** segments,
                                                uint64_t* sizes, uint64_t* num_segments);

// Sets the message proto data as bytes
// Inputs:
//   app_handle:    A handle to the application which contains the desired message.
//   message_uuid:  UUID of the message.
//   segments:      Array of pointers to segments data
//   sizes:         Array of sizes of each segments in bytes
//   num_segments:  Number of segments
// Error Codes:
//   isaac_error_success
//   isaac_error_invalid_handle
//   isaac_error_cannot_modify_received_message
//
isaac_error_t isaac_set_message_proto_segments(isaac_handle_t app_handle,
                                               isaac_uuid_t* message_uuid, const void** segments,
                                               const int64_t* sizes, const int64_t num_segments);
// Gets buffers associated with a message
//
// This function follows the general schema of getting a list of items used in the ISAAC C API.
// the corresponding data is not provided. In any case the number of buffers is returned.
//
// In case a buffer is available in multiple storage options `preferred_storage` is chosen.
isaac_error_t isaac_message_get_buffers(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                        isaac_buffer_t* buffers, int64_t* buffer_count,
                                        isaac_memory_t preferred_storage);

// Appends a new empty buffer to a message
//
// This is an invalid operation for received messages which were not created by the user.
//
// The function allocates memory for a new buffer which will be added to the message. The caller
// keeps ownership of the provided buffer.
isaac_error_t isaac_message_append_buffer(isaac_handle_t app_handle, isaac_uuid_t* message_uuid,
                                          const isaac_buffer_t* buffer, int64_t* buffer_index);

// Gets time difference between ISAAC app and host application
//
// Input parameter is host application time in seconds.
// Output is (ISAAC app time) - (host time) in nano seconds.
isaac_error_t isaac_get_external_time_difference(isaac_handle_t app_handle, double external_time,
                                                 int64_t* difference);

//==================================================================================================
// HELPER FUNCTIONS
//==================================================================================================

// Creates an empty JSON object with null pointer and size 0.
isaac_json_t isaac_create_null_json();

// Creates an empty JSON object with null pointer and size 0.
isaac_const_json_t isaac_create_null_const_json();

#ifdef __cplusplus
}
#endif
